#!/usr/bin/env node
"use strict";

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _util = _interopRequireDefault(require("util"));

var _yargs = _interopRequireDefault(require("yargs"));

var _s = require("./lib/s3");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const mkdir = _util.default.promisify(_fs.default.mkdir);

const writeFile = _util.default.promisify(_fs.default.writeFile);

const {
  argv
} = _yargs.default.usage('$0 [options]').help('h').alias('h', 'help').demandOption('bucket').option('bucket', {
  alias: 'b',
  description: 'Bucket name',
  type: 'string'
}).option('prefix', {
  alias: '-p',
  description: 'Prefix for files',
  type: 'string'
}).option('out-dir', {
  alias: 'd',
  description: 'output',
  type: 'string',
  default: process.cwd()
});

const {
  bucket,
  prefix,
  outDir
} = argv;

(async () => {
  if (prefix) {
    const data = await (0, _s.listObjectVersions)({
      Bucket: bucket,
      Prefix: prefix
    });

    for (const version of data.Versions) {
      const ts = new Date(version.LastModified).getTime();
      const splited = version.Key.split(/\//gi);
      const filename = `${ts}_${splited.splice(splited.length - 1)[0]}`;

      const dir = _path.default.join(outDir, splited.join('/'));

      await mkdir(dir, {
        recursive: true
      });
      const object = await (0, _s.getObject)({
        VersionId: version.VersionId,
        Key: version.Key,
        Bucket: bucket
      });
      console.log(`${version.Key} is downloading...`);
      await writeFile(_path.default.join(dir, filename), object.Body);
    }
  }
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJta2RpciIsInV0aWwiLCJwcm9taXNpZnkiLCJmcyIsIndyaXRlRmlsZSIsImFyZ3YiLCJ5YXJncyIsInVzYWdlIiwiaGVscCIsImFsaWFzIiwiZGVtYW5kT3B0aW9uIiwib3B0aW9uIiwiZGVzY3JpcHRpb24iLCJ0eXBlIiwiZGVmYXVsdCIsInByb2Nlc3MiLCJjd2QiLCJidWNrZXQiLCJwcmVmaXgiLCJvdXREaXIiLCJkYXRhIiwiQnVja2V0IiwiUHJlZml4IiwidmVyc2lvbiIsIlZlcnNpb25zIiwidHMiLCJEYXRlIiwiTGFzdE1vZGlmaWVkIiwiZ2V0VGltZSIsInNwbGl0ZWQiLCJLZXkiLCJzcGxpdCIsImZpbGVuYW1lIiwic3BsaWNlIiwibGVuZ3RoIiwiZGlyIiwicGF0aCIsImpvaW4iLCJyZWN1cnNpdmUiLCJvYmplY3QiLCJWZXJzaW9uSWQiLCJjb25zb2xlIiwibG9nIiwiQm9keSJdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7O0FBRUEsTUFBTUEsS0FBSyxHQUFHQyxjQUFLQyxTQUFMLENBQWVDLFlBQUdILEtBQWxCLENBQWQ7O0FBQ0EsTUFBTUksU0FBUyxHQUFHSCxjQUFLQyxTQUFMLENBQWVDLFlBQUdDLFNBQWxCLENBQWxCOztBQUVBLE1BQU07QUFBRUMsRUFBQUE7QUFBRixJQUFXQyxlQUNkQyxLQURjLENBQ1IsY0FEUSxFQUVkQyxJQUZjLENBRVQsR0FGUyxFQUdkQyxLQUhjLENBR1IsR0FIUSxFQUdILE1BSEcsRUFJZEMsWUFKYyxDQUlELFFBSkMsRUFLZEMsTUFMYyxDQUtQLFFBTE8sRUFLRztBQUNoQkYsRUFBQUEsS0FBSyxFQUFFLEdBRFM7QUFFaEJHLEVBQUFBLFdBQVcsRUFBRSxhQUZHO0FBR2hCQyxFQUFBQSxJQUFJLEVBQUU7QUFIVSxDQUxILEVBVWRGLE1BVmMsQ0FVUCxRQVZPLEVBVUc7QUFDaEJGLEVBQUFBLEtBQUssRUFBRSxJQURTO0FBRWhCRyxFQUFBQSxXQUFXLEVBQUUsa0JBRkc7QUFHaEJDLEVBQUFBLElBQUksRUFBRTtBQUhVLENBVkgsRUFlZEYsTUFmYyxDQWVQLFNBZk8sRUFlSTtBQUNqQkYsRUFBQUEsS0FBSyxFQUFFLEdBRFU7QUFFakJHLEVBQUFBLFdBQVcsRUFBRSxRQUZJO0FBR2pCQyxFQUFBQSxJQUFJLEVBQUUsUUFIVztBQUlqQkMsRUFBQUEsT0FBTyxFQUFFQyxPQUFPLENBQUNDLEdBQVI7QUFKUSxDQWZKLENBQWpCOztBQXNCQSxNQUFNO0FBQUVDLEVBQUFBLE1BQUY7QUFBVUMsRUFBQUEsTUFBVjtBQUFrQkMsRUFBQUE7QUFBbEIsSUFBNkJkLElBQW5DOztBQUVBLENBQUMsWUFBWTtBQUNYLE1BQUlhLE1BQUosRUFBWTtBQUNWLFVBQU1FLElBQUksR0FBRyxNQUFNLDJCQUFtQjtBQUFFQyxNQUFBQSxNQUFNLEVBQUVKLE1BQVY7QUFBa0JLLE1BQUFBLE1BQU0sRUFBRUo7QUFBMUIsS0FBbkIsQ0FBbkI7O0FBRUEsU0FBSyxNQUFNSyxPQUFYLElBQXNCSCxJQUFJLENBQUNJLFFBQTNCLEVBQXFDO0FBQ25DLFlBQU1DLEVBQUUsR0FBRyxJQUFJQyxJQUFKLENBQVNILE9BQU8sQ0FBQ0ksWUFBakIsRUFBK0JDLE9BQS9CLEVBQVg7QUFFQSxZQUFNQyxPQUFPLEdBQUdOLE9BQU8sQ0FBQ08sR0FBUixDQUFZQyxLQUFaLENBQWtCLE1BQWxCLENBQWhCO0FBQ0EsWUFBTUMsUUFBUSxHQUFJLEdBQUVQLEVBQUcsSUFBR0ksT0FBTyxDQUFDSSxNQUFSLENBQWVKLE9BQU8sQ0FBQ0ssTUFBUixHQUFpQixDQUFoQyxFQUFtQyxDQUFuQyxDQUFzQyxFQUFoRTs7QUFDQSxZQUFNQyxHQUFHLEdBQUdDLGNBQUtDLElBQUwsQ0FBVWxCLE1BQVYsRUFBa0JVLE9BQU8sQ0FBQ1EsSUFBUixDQUFhLEdBQWIsQ0FBbEIsQ0FBWjs7QUFFQSxZQUFNckMsS0FBSyxDQUFDbUMsR0FBRCxFQUFNO0FBQUVHLFFBQUFBLFNBQVMsRUFBRTtBQUFiLE9BQU4sQ0FBWDtBQUVBLFlBQU1DLE1BQU0sR0FBRyxNQUFNLGtCQUFVO0FBQzdCQyxRQUFBQSxTQUFTLEVBQUVqQixPQUFPLENBQUNpQixTQURVO0FBRTdCVixRQUFBQSxHQUFHLEVBQUVQLE9BQU8sQ0FBQ08sR0FGZ0I7QUFHN0JULFFBQUFBLE1BQU0sRUFBRUo7QUFIcUIsT0FBVixDQUFyQjtBQU1Bd0IsTUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQWEsR0FBRW5CLE9BQU8sQ0FBQ08sR0FBSSxvQkFBM0I7QUFFQSxZQUFNMUIsU0FBUyxDQUFDZ0MsY0FBS0MsSUFBTCxDQUFVRixHQUFWLEVBQWVILFFBQWYsQ0FBRCxFQUEyQk8sTUFBTSxDQUFDSSxJQUFsQyxDQUFmO0FBQ0Q7QUFDRjtBQUNGLENBeEJEIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJztcblxuaW1wb3J0IHlhcmdzIGZyb20gJ3lhcmdzJztcbmltcG9ydCB7IGxpc3RPYmplY3RWZXJzaW9ucywgZ2V0T2JqZWN0IH0gZnJvbSAnLi9saWIvczMnO1xuXG5jb25zdCBta2RpciA9IHV0aWwucHJvbWlzaWZ5KGZzLm1rZGlyKTtcbmNvbnN0IHdyaXRlRmlsZSA9IHV0aWwucHJvbWlzaWZ5KGZzLndyaXRlRmlsZSk7XG5cbmNvbnN0IHsgYXJndiB9ID0geWFyZ3NcbiAgLnVzYWdlKCckMCBbb3B0aW9uc10nKVxuICAuaGVscCgnaCcpXG4gIC5hbGlhcygnaCcsICdoZWxwJylcbiAgLmRlbWFuZE9wdGlvbignYnVja2V0JylcbiAgLm9wdGlvbignYnVja2V0Jywge1xuICAgIGFsaWFzOiAnYicsXG4gICAgZGVzY3JpcHRpb246ICdCdWNrZXQgbmFtZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gIH0pXG4gIC5vcHRpb24oJ3ByZWZpeCcsIHtcbiAgICBhbGlhczogJy1wJyxcbiAgICBkZXNjcmlwdGlvbjogJ1ByZWZpeCBmb3IgZmlsZXMnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICB9KVxuICAub3B0aW9uKCdvdXQtZGlyJywge1xuICAgIGFsaWFzOiAnZCcsXG4gICAgZGVzY3JpcHRpb246ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGRlZmF1bHQ6IHByb2Nlc3MuY3dkKCksXG4gIH0pO1xuXG5jb25zdCB7IGJ1Y2tldCwgcHJlZml4LCBvdXREaXIgfSA9IGFyZ3Y7XG5cbihhc3luYyAoKSA9PiB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgbGlzdE9iamVjdFZlcnNpb25zKHsgQnVja2V0OiBidWNrZXQsIFByZWZpeDogcHJlZml4IH0pO1xuXG4gICAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIGRhdGEuVmVyc2lvbnMpIHtcbiAgICAgIGNvbnN0IHRzID0gbmV3IERhdGUodmVyc2lvbi5MYXN0TW9kaWZpZWQpLmdldFRpbWUoKTtcblxuICAgICAgY29uc3Qgc3BsaXRlZCA9IHZlcnNpb24uS2V5LnNwbGl0KC9cXC8vZ2kpO1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBgJHt0c31fJHtzcGxpdGVkLnNwbGljZShzcGxpdGVkLmxlbmd0aCAtIDEpWzBdfWA7XG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmpvaW4ob3V0RGlyLCBzcGxpdGVkLmpvaW4oJy8nKSk7XG5cbiAgICAgIGF3YWl0IG1rZGlyKGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgICAgIGNvbnN0IG9iamVjdCA9IGF3YWl0IGdldE9iamVjdCh7XG4gICAgICAgIFZlcnNpb25JZDogdmVyc2lvbi5WZXJzaW9uSWQsXG4gICAgICAgIEtleTogdmVyc2lvbi5LZXksXG4gICAgICAgIEJ1Y2tldDogYnVja2V0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGAke3ZlcnNpb24uS2V5fSBpcyBkb3dubG9hZGluZy4uLmApO1xuXG4gICAgICBhd2FpdCB3cml0ZUZpbGUocGF0aC5qb2luKGRpciwgZmlsZW5hbWUpLCBvYmplY3QuQm9keSk7XG4gICAgfVxuICB9XG59KSgpO1xuIl19